module tst (
    input clk,  // clock
    input rst,  // reset
    
    // confirm to next state button
    input button,
    // only need output to show it on the screen
    output seg[16],
    output out[16]
  ) {
  
    .clk(clk) {
    edge_detector edge;
      .rst(rst) {
        fsm state = {BEGIN, ADD, SUB, MUL, AND, OR, XOR, A, SHL, SHR,
         SRA, CMPEQ, CMPLE, CMPLT, GOOD, ERROR};
      dff timer[27];
      dff counter[4];
      
      addTest addTest(.button(button), .count(counter.q));
      subTest subTest(.button(button), .count(counter.q));
      mulTest mulTest(.button(button), .count(counter.q));
      orTest  orTest(.button(button), .count(counter.q));
      andTest andTest(.button(button), .count(counter.q));
      xorTest xorTest(.button(button), .count(counter.q));
      bolATest bolATest(.button(button), .count(counter.q));
      shlTest shlTest(.button(button), .count(counter.q));
      shrTest shrTest(.button(button), .count(counter.q));
      sraTest sraTest(.button(button), .count(counter.q));
      cmpeqTest cmpeqTest(.button(button), .count(counter.q));
      cmpleTest cmpleTest(.button(button), .count(counter.q));
      cmpltTest cmpltTest(.button(button), .count(counter.q));
    }
  }
  
  always {
    
    // default assign
    seg=0;
    out=0;
    
    timer.d = timer.q+1;
    edge.in = button;
    
    case(state.q) {
      state.BEGIN:
        seg = c{13,14,15,13}; // TEST
        if (edge.out) {
          counter.d = counter.q+1;
          state.d = state.ADD;
        }
      
      // ADD
      state.ADD:
        out = addTest.out;
        seg = c{1,11,11,11}; 
        // duration 1s
        if(addTest.true==1){
          counter.d = counter.q+4;
          state.d = state.AND;
        }
        
        
      // SUB
      state.SUB:
      out = subTest.out;
        
        seg = c{2,11,11,11}; 
        // duration 1s
        if (subTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.MUL;
        }
        
      // MUL
      state.MUL:
      out = mulTest.out;
        
        seg = c{3,11,11,11}; 
        // duration 1s
        if (mulTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.OR;
        }
        
      // OR
      state.OR:
      out = orTest.out;
        
        seg = c{4,11,11,11}; 
        // duration 1s
        if (orTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.ADD;
        }
      
      // AND
      state.AND:
        out = andTest.out;
        
        seg = c{5,11,11,11}; 
        // duration 1s
        if (andTest.true) {
          counter.d = counter.q+1;
          state.d = state.XOR;
        }
        
      // XOR
      state.XOR:
      out = xorTest.out;
        
        seg = c{6,11,11,11};
        // duration 1s
        if (xorTest.true) {
          counter.d = counter.q+1;
          state.d = state.A;
        }
        
      // A
      state.A:
      out = bolATest.out;
       
        seg = c{7,11,11,11}; 
        // duration 1s
        if (bolATest.true) {
          counter.d = counter.q+1;
          state.d = state.SHL;
        }
        
      // SHL
      state.SHL:
      out = shlTest.out;
       
        seg = c{8,11,11,11};
        // duration 1s
        if (shlTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.SHR;
        
        }
        
      // SHR
      state.SHR:
      out = shrTest.out;
       
        seg = c{9,11,11,11}; 
        // duration 1s
        if (shrTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.SRA;
        }
        
      // SRA
      state.SRA:
      out = sraTest.out;
        
        seg = c{1,0,11,11}; 
        // duration 1s
        if (sraTest.true) {
          counter.d = counter.q+1;
          state.d = state.CMPEQ;
        }
        
      // CMPEQ
      state.CMPEQ:
      out = cmpeqTest.out;
        
        seg = c{1,1,11,11}; 
        // duration 1s
        if (cmpeqTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.CMPLE;
        }
        
      // CMPLE
      state.CMPLE:
      out = cmpleTest.out;
       
        seg = c{1,2,11,11}; 
        // duration 1s
        if (cmpleTest.true==1) {
          counter.d = counter.q+1;
          state.d = state.CMPLT;
        }
        
      // CMPLT
      state.CMPLT:
      out = cmpltTest.out;
        
        seg = c{1,3,11,11}; 
        // duration 1s
        if (cmpleTest.true) {
          counter.d = counter.q+1;
          state.d = state.GOOD;
        }
        
      // GOOD
      state.GOOD:
        seg = c{10,11,11,12};
        
      // ERROR
      state.ERROR:
        seg = c{11,11,11,11};
  }
}
}

